module OneCobs
using Docile
@docstrings
import Base:in,show
using Graphs

export PortPair,OneCob,gcompose,gotimes, isloop
export id,ev,coev
# A representation of a FTS in this category will calculate the normal form 
# when evaluated.

################################################################################
# Types
################################################################################
type PortPair
    cod::Array{Symbol,1}
    dom::Array{Symbol,1}
end
in(item,p::PortPair) = item in p.cod || item in p.dom
in(item,ps::Array{PortPair}) = any([item in p for p in ps])
# warning, flipped order
PortPair(d::Integer,c::Integer) = PortPair([gensym() for i in 1:c],[gensym() for i in 1:d]) 

type OneCob
    graph::GenericAdjacencyList{KeyVertex{Symbol},Array{KeyVertex{Symbol},1},Array{Array{KeyVertex{Symbol},1},1}}
    innerports::Array{PortPair,1}
    outerports::PortPair
    loops::Array{Symbol}
    label #usually a symbol
end
OneCob(graph,innerports,outerports,loops)=OneCob(graph,innerports,outerports,loops,:unlabeled) #default label


################################################################################
# Utilities
################################################################################
# assumes NO OVERLAP IN KEYS which is reasonable because they are generated by
# gensym().  If this changes, so must this function.
function disjoint_union(g,h)#::GenericAdjacencyList,h::GenericAdjacencyList)
    g = deepcopy(g)
    index=Dict([ (v.key,v.index) for v in g.vertices  ]) #not in Graphs.jl?
    
    for v in h.vertices
        newv=add_vertex!(g,v.key)
        index[newv.key]=newv.index
    end
    
    for v in h.vertices
        for u in out_neighbors(v,h)
            if g.vertices[index[v.key]] in out_neighbors(g.vertices[index[u.key]], g) #otherwise will add multiple edges, two for each edge
                nothing
            else
                add_edge!(g, g.vertices[index[v.key]],g.vertices[index[u.key]])
            end
        end
    end
    return (g,index)
end

onecobgraph()=adjlist(KeyVertex{Symbol}, is_directed=false)

function show(io::IO,v::KeyVertex{Symbol})
    print(io,"(",join([v.index,string(v.key)[end-2:end]],","),")")
end

function isloop(g::OneCob)
    length(g.loops)==1 &&
    isempty(g.graph.vertices) &&
    isempty(g.graph.adjlist)
end



################################################################################
# 2-ary ops
################################################################################
@doc "Apply a ∘ op to two Hom-typed arguments and simplify." ->
function gcompose(phi::OneCob,psi::OneCob)
    innerports = [phi.innerports;psi.innerports] 
    outerports = PortPair(phi.outerports.cod,psi.outerports.dom)
    # println("innerports: ",innerports)
    # println("outerports: ",outerports)
    loops = [phi.loops;psi.loops] # this may grow when simplifying
    # initialize a big graph whose vertices are the symbols of all nonloop ports
    g, index = disjoint_union(phi.graph,psi.graph)
    
    # draw all new edges (identity edges are not needed since we use the ports
    # that would get them as our new external ports
    # this will be different for ⊗
    # println("phi.outerports.dom: ",phi.outerports.dom)
    n=length(phi.outerports.dom) #(==length(psi.outerports.cod))
    for i=1:n
        phiport = phi.outerports.dom[i]
        psiport = psi.outerports.cod[i]
        # println("add edge ", g.vertices[index[phiport]], g.vertices[index[psiport]])
        add_edge!(g, g.vertices[index[phiport]], g.vertices[index[psiport]])
    end


    # Make a new graph to hold the answer.
    h = onecobgraph() #adjlist(KeyVertex{Symbol}, is_directed=false)

    # Simplify.  Each connected component is an edge of the new graph, iff 
    # it contains two external vertices; otherwise it contains no external 
    # vertices and is a loop.
    cc=connected_components(g)
#    return g
    # println("Connected components: ",cc)
    for vs in cc
        # find the two exits if they exist
        externals = filter(x->(x.key in outerports) || (x.key in innerports),
                           vs)
        if !isempty(externals)
            @assert length(externals)==2 println(externals," wrong length")
            # Add the new edge. I can assume neither side is already added to h, 
            # since these are connected components
            a=add_vertex!(h,externals[1].key)
            b=add_vertex!(h,externals[2].key)
            add_edge!(h,a,b)
        elseif vs==[] #was if externals==[], exactly the loop case.
            nothing
        else # this has resulted in a loop.  Take the first symbol is a tag
            @assert externals==[]
            # println(vs," is a loop")
            push!(loops,vs[1].key)
        end
    end
    #    return (h,innerports,outerports,loops)
    @assert phi.label==psi.label println("Label mismatch for OneCobs ",
                                         phi," ",psi)
    OneCob(h,innerports,outerports,loops,phi.label)

end


@doc "Apply an ⊗ op to two Hom-typed arguments and simplify." ->
function gotimes(phi,psi)
    innerports = [phi.innerports;psi.innerports] 
    outerports = PortPair([phi.outerports.cod ; psi.outerports.cod],
                          [phi.outerports.dom ; psi.outerports.dom])
    loops = [phi.loops;psi.loops] 
    g, index = disjoint_union(phi.graph,psi.graph)
    @assert phi.label==psi.label println("Label mismatch for OneCobs ",
                                         phi," ",psi)
    OneCob(g,innerports,outerports,loops,phi.label)
end


################################################################################
# 1-ary ops
################################################################################

################################################################################
# 0-ary ops
################################################################################
@doc " ev: I->A⊗A as a 0-ary op; argument becomes the label of the resulting OneCob.  Note this is a function, rather than a constant, because we need to generate fresh symbols with gensym() for each ev(something) that appears in an expression.  Each symbol corresponds to a different port or vertex." ->
function ev(A::Symbol)
    g  =  onecobgraph() # adjlist(KeyVertex{Symbol}, is_directed=false)

    pp = PortPair(2,0) #I->A_⊗A
    u1 = add_vertex!(g,pp.dom[1])
    u2 = add_vertex!(g,pp.dom[2])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,A)
end

function coev(A::Symbol)
    g  =  onecobgraph() # adjlist(KeyVertex{Symbol}, is_directed=false)

    pp = PortPair(0,2) #A⊗A_ ->I
    u1 = add_vertex!(g,pp.cod[1])
    u2 = add_vertex!(g,pp.cod[2])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,A)
end

function id(A::Symbol)
    g  =  onecobgraph()

    pp = PortPair(1,1) #A->A
    u1 = add_vertex!(g,pp.cod[1])
    u2 = add_vertex!(g,pp.dom[1])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,A)
    
end

#unfinished, not clear how to represent this
#could just decorate an edge with a symbol maybe, in A->A case
function morvar(ndomwires,ncodwires) #A,A? A,B? dom,cod?  only hand one object now. but morvar could have multi inputs and outputes.
    g  =  onecobgraph()

    pp = PortPair(ndomwires,ncodwires) #A^{⊗ndomwires}->A^{⊗ncodwires}
    for i=1:ncodwires
        u1 = add_vertex!(g,pp.cod[1])
    end
    u2 = add_vertex!(g,pp.dom[1])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops)
    
end






function ev(nwires::Integer)
    g  =  onecobgraph() # adjlist(KeyVertex{Symbol}, is_directed=false)

    pp = PortPair(2,0) #I->A_⊗A
    u1 = add_vertex!(g,pp.dom[1])
    u2 = add_vertex!(g,pp.dom[2])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,nwires)
end

function coev(A)
    g  =  onecobgraph() # adjlist(KeyVertex{Symbol}, is_directed=false)

    pp = PortPair(0,2) #A⊗A_ ->I
    u1 = add_vertex!(g,pp.cod[1])
    u2 = add_vertex!(g,pp.cod[2])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,A)
end

function id(A)
    g  =  onecobgraph()

    pp = PortPair(1,1) #A->A
    u1 = add_vertex!(g,pp.cod[1])
    u2 = add_vertex!(g,pp.dom[1])

    add_edge!(g,u1,u2)
    innerports = []
    outerports = pp
    loops = []

    OneCob(g,innerports,outerports,loops,A)
    
end





end #module







